# design-patterns
Creational Design Pattern -Creational design patterns solve the problems related to object creation. They help to abstract away object creation processes that spread across multiple classes.

a.Singleton
b.Factory Method
c.Abstract Factory
d.Builder
e.Prototype


2.Structural Design Patterns : The structural design patterns suggest implementing relationships between classes and objects.

a.Adapter
b.Bridgec
c.Composite
d.Decorator
f.Facade
g.Flyweight
h.Proxy

 

===================singleTon Design Patter =============================

public sealed class SingleTon
{
    private static SingleTon _instance = null;
    private static readonly Object padlock = new Object();

    private SingleTon() { }

    public static SingleTon Instance{
        get{
            lock(padlock)
            {
                if(_instance == null){
                    _instance = new SingleTon();
                }
                return _instance;
            }
        }   
    }
} 

======================C# Factory Method Design Pattern======================

The Factory Method design pattern defines an interface for creating an object, but let subclasses decide which class to instantiate. This pattern lets a class defer instantiation to subclasses.


Factory Method is a creational design pattern that provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.


public interface INotification
{
    void SendNotification();
}


public class EmailNotification : INotification
{
    public void SendNotification
    {
        Console.WriteLine("Sending email notification")
    }
}


public class SMSNotification : INotification
{
    public void SendNotification()
    {
        Console.WriteLine("Sending sms notification");   
    }
}


public abstract class NotificationFactory
{
    public abstract INotification CreateNotification();
}

public class EmailNotificationFactory : INotificationFactory
{
    public override INotification CreateNotification()
    {
        return new EmailNotification();
    }
}


public SMSNotificationFactory : NotificationFactory
{
    public overide INotification CreateNotification()
    {
        return SMSNotification();
    }
}

class Program {
    static void Main(string[] args)
    {

        Notificationfactory emailFactory = new EmailNotificationFactory();
        INotification emailNotification = emailFactory.createNotification();
        emailNotification.SendNotification();

        NotificationFactory smsFactory = new SMSNotificationFactory();
        INotification smsNotification = smsFactory.CreateNotification();
        smsNotification.SendNotification();
    }
}


===============Abstract Factory===================

The Abstract Factory design pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes.

public interface INotification
{
    void Send();
}


public void EmailNotification : INotification
{
    public void Send()
    {
        Console.WriteLine("Sending email notification");
    }
}


public void SMSNotification : INotification
{
    public void Send()
    {
        Console.WriteLine("Send SMS notification")
    }
}

public interface INotificationFactory
{
    INotification CreateEmailNotification();
    INotification CreateSMSNotification();
}

public class NotificationFactory : INotificationFactory
{
    public INotification CreateEmailNotification()
    {
         return new EmailNotification();
    }

    public INotification CreateSMSNotification()
    {
        return new SMSNotification();
    }
}

class Program
{
    //create a notification factory

    INotificationFactory notificationFactory = new NotificationFactory();

    //create an email notification
    INotification emailNotification = notificationFactory.createEmailNotification();
    emailNotification.Send();

    //create an SMS notification
    INotification smsNotification = notificationFactory.createSMSNotification();
    smsNotification.Send();
}

===================================Builder design pattern===========================================

The Builder design pattern separates the construction of a complex object from its representation so that the same construction process can create different representations.

**Builder :** This is an interface which is used to define all the steps required to create a product.

**ConcreteBuilder :** This is a class which implements the Builder interface to create a complex product.

**Product :** This is a class which defines the parts of the complex object which are to be generated by the Builder Pattern.

**Director :** This is a class that is used to construct an object using the Builder interface.

 
**WHEN TO USE THIS PATTERN :** When we need to create a complex object in several steps (a step by step approach).

**ADVANTAGES**

- Code is more maintainable and readable.

- Less prone to errors as we have a method which returns the finally constructed object.

**DISADVANTAGES**

- Number of lines of code increases in builder pattern, but it makes sense as the effort pays off in terms of maintainability and readability.

**Conclusion**

So, if your object has only a few constructor arguments, it makes no sense to use the builder pattern. Builder pattern is a good choice when designing classes whose constructors have more than a handful of parameters.

```
using System;
					
public class Program
{
	public static void Main()
	{
		var builder = new NotificationBuilder();
		var director = new Director(builder);
		director.ConstructNotification("Greetings", "Greetings of the day!", "test@gmail.com");
		var notification = builder.Build();	
		notification.PrintDetails();
	}
}

//product
public class Notification
{
	public string Title {get;set;}
	public string Body {get;set;}
	public string Recipient {get;set;}
	
	public void PrintDetails()
	{
		Console.WriteLine("Title : "+ Title + " Body : " + Body+ "Receipient "+ Recipient);
	}
}

//builder interface
public interface INotificationBuilder
{
	void SetTitle(string title);
	void SetBody(string body);
	void SetRecipient(string recipient);
	
	Notification Build();
}

public class NotificationBuilder : INotificationBuilder
{
	private Notification _notification = new Notification();
	
	public void SetTitle(string title)
	{
		_notification.Title = title;	
	}
	
	public void SetBody(string body)
	{
		_notification.Body = body;
	}
	
	public void SetRecipient( string recipient)
	{
		_notification.Recipient = recipient;
	}
	
	public Notification Build()
	{
		return _notification;
	}
}

//Director
public class Director
{
	private INotificationBuilder _builder;
	public Director(INotificationBuilder notificationBuilder)
	{
		_builder = notificationBuilder;
	}
	
	public void ConstructNotification(string title, string body, string recipient)
	{
		_builder.SetTitle(title);
		_builder.SetBody(body);
		_builder.SetRecipient(recipient);
	}
	
}

```

**==================================Adapter Design Pattern============**

The Adapter design pattern converts the interface of a class into another interface clients expect. This design pattern lets classes work together that couldnâ€˜t otherwise because of incompatible interfaces.

The Adapter Design pattern is a structural pattern that allows object with incompatible interfaces to work together.It acts as bridge between the old and new interfaces, enabling them to collaborate seamlessly.

```
public interface IWeatherService
{
    float GetTemperatureInCelsius();
}

public class FarenheitWeatherServiceAdapter : IWeatherService
{
    private readonly ExternalWeatherService _externalWeatherService;

    public FarenheitWeatherServiceAdapter(ExternalWeatherService externalService){

        _externalService = externalService;
    }

    public float GetTemperatureInCelsius(){

        //convert Farenheit to celcius

        float temperatureInFarenheit = _externalWeatherService.GetTemperature();

        return (temperatur - 32) *5 / 9;

    }

}
```
**======================================================Bridge Design Patter =================================================**

The Bridge design pattern allows you to separate the abstraction from the implementation,so that the two can vary independently.

The bridge design pattern is a type of structural design pattern which is used to split a large class into two separate inheritance hierarchies (a collection of 'is-a' relationships); one for the implementations and one for the abstractions. These hierarchies are then connected to each other via object composition, forming a bridge-like structure. This pattern is also known as the Handle-Body Design Pattern.

``` 
namespace BridgePatternRealTimeExample
{
    /** 
    This is going to be an interface that acts as a bridge between the Abstraction Layer and Implementation Layer
    The following Implementor Interface defines the operations for all implementation classes. It doesn't have to match the Abstraction's interface.
    In fact, the two interfaces can be entirely different.
     **/

    public interface IMessageSender
    {
        void SendMessage(string Message);
    }
}

 
using System;
namespace BridgePatternRealTimeExample
{
    /** 
    This is going to be a class that implements the Implementor Interface i.e. IMessageSender. It also provides the implementation details for the associated Abstraction class. Each Concrete Implementation corresponds to a specific platform, in this case sending messages using SMS.
    **/

    public class SmsMessageSender : IMessageSender
    {
        public void SendMessage(string Message)
        {
            //Send a message using SMS
            Console.WriteLine("'" + Message + "'   : This Message has been sent using SMS");
        }
    }
}

 
using System;
namespace BridgePatternRealTimeExample
{
    /** 
    This is going to be a class that implements the Implementor Interface i.e. IMessageSenderIt also provides the implementation details for the associated Abstraction class. Each Concrete Implementation corresponds to a specific platform, in this case sending messages using Email.
    **/

    public class EmailMessageSender : IMessageSender
    {
        public void SendMessage(string Message)
        {
            Console.WriteLine("'" + Message + "'   : This Message has been sent using Email");
        }
    }
}

 
namespace BridgePatternRealTimeExample
{
    /**
    This is an abstract class that going to be implemented by the Concrete Abstraction. It contains a reference to an object of type IMessageSender Interface i.e. messageSender and delegates all of the real work to this object (the class that implements IMessageSender Interface). It can also act as the base class for other abstractions.
    **/

    public abstract class AbstractMessage
    {
        protected IMessageSender messageSender;
        public abstract void SendMessage(string Message);
    }
}

using System;
namespace BridgePatternRealTimeExample
{
    /** 
    This is going to be a concrete class which inherits from the Abstraction class i.e. AbstractMessage. This Concrete Abstraction Class implements the operations defined by AbstractMessage class.
    **/

    public class ShortMessage : AbstractMessage
    {
        //The constructor expected an argument of type object which implements the IMessageSender interface

        public ShortMessage(IMessageSender messageSender)
        {
            //Initialize the super class messageSender variable

            this.messageSender = messageSender;
        }

        public override void SendMessage(string Message)
        {
            if (Message.Length <= 10)
            {
                messageSender.SendMessage(Message);
            }
            else
            {
                Console.WriteLine("Unable to send the message as length > 10 characters");
            }
        }
    }
}
 
namespace BridgePatternRealTimeExample
{
    /** 
    This is going to be a concrete class that inherits from the Abstraction class i.e. AbstractMessage. This Concrete Abstraction Class implements the operations defined by AbstractMessage class.
    **/

    public class LongMessage : AbstractMessage
    {
        public LongMessage(IMessageSender messageSender)
        {
            //Initialize the super class messageSender variable
            this.messageSender = messageSender;
        }

        public override void SendMessage(string Message)
        {
            messageSender.SendMessage(Message);
        }
    }
}

 
using System;
namespace BridgePatternRealTimeExample
{
    class Program
    {
        static void Main(string[] args)
        {
            /** 
            Except for the initialization phase, where an Abstraction object i.e. LongMessage or ShortMessage linked with a specific Implementation object i.e. new EmailMessageSender() or new SmsMessageSender(), the client code should only depend on the Abstraction class i.e. AbstractMessage
            **/
 
            Console.WriteLine("Select the Message Type 1. For longmessage or 2. For shortmessage");
            int MessageType = Convert.ToInt32(Console.ReadLine());

            Console.WriteLine("Please enter the message that you want to send");

            string Message = Console.ReadLine();

            if (MessageType == 1)
            {
                AbstractMessage longMessage = new LongMessage(new EmailMessageSender());
                longMessage.SendMessage(Message);
            }
            else
            {
                AbstractMessage shortMessage = new ShortMessage(new SmsMessageSender());
                shortMessage.SendMessage(Message);
            }
 
            Console.ReadKey();
        }
    }
}

```


**=================================================Facade Design Patter ============================================================**

Facade pattern hides the complexities of the system and provides an interface to the client using which the client can access the system. Facade is a structural design pattern that provides a simplified interface to a complex system making it easier to use.

This pattern involves a single wrapper class which contains a set of members which are required by the client. These members access the system on behalf of the facade client and hide the implementation details.

The facade design pattern is particularly used when a system is very complex or difficult to understand because the system has a large number of interdependent classes or its source code is unavailable.

Facade Design pattern falls under Structural Pattern. The Facade design pattern is particularly used when a system is very complex or difficult to understand because the system has a large number of interdependent classes or its source code is unavailable.
 

Example without using Facade Design Pattern
 
```
namespace FacadeDesignPatternRealTimeExample
{
    public class Customer
    {
        public string Name { get; set; }
        public string Email { get; set; }
        public string MobileNumber { get; set; }
        public string Address { get; set; }
        //Any other Properties as per the Business Requirements
    }
}


using System;
namespace FacadeDesignPatternRealTimeExample
{
    public class Validator
    {
        public bool ValidateCustomer(Customer customer)
        {
            //Need to Validate the Customer Object
            Console.WriteLine("Customer Validated...");
            Console.WriteLine($"Name:{customer.Name}");
            Console.WriteLine($"Email:{customer.Email}");
            Console.WriteLine($"Mobile:{customer.MobileNumber}");
            Console.WriteLine($"Address:{customer.Address}");

            return true;
        }
    }
}

using System;
namespace FacadeDesignPatternRealTimeExample
{
    public class CustomerDataAccessLayer
    {
        public bool SaveCustomer(Customer customer)
        {
            //Save the Customer in the Database
            Console.WriteLine("\nCustomer Saved into the Database...");

            return true;
        }
    }
}

using System;
namespace FacadeDesignPatternRealTimeExample
{
    public class Email
    {
        public bool SendRegistrationEmail(Customer customer)
        {
            //Send Registration Successful Email to Customer
            Console.WriteLine("\nRegistration Email Send to Customer...");

            return true;
        }
    }
}

 
using System;
namespace FacadeDesignPatternRealTimeExample
{
    class Program
    {
        static void Main(string[] args)
        {
            //Step1: Create an Instance of Customer Class
            Customer customer = new Customer()
            {
                Name = "Pranaya",
                Email = info@dotnettutorials.net,
                MobileNumber = "1234567890",
                Address = "BBSR, Odisha, India"
            };

            //Step2: Validate the Customer
            Validator validator = new Validator();
            bool IsValid = validator.ValidateCustomer(customer);

            //Step3: Save the Customer Object into the database
            CustomerDataAccessLayer customerDataAccessLayer = new CustomerDataAccessLayer();
            bool IsSaved = customerDataAccessLayer.SaveCustomer(customer);

            //Step4: Send the Registration Email to the Customer
            Email email = new Email();
            email.SendRegistrationEmail(customer);

            Console.ReadKey();
        }
    }
}

```

**Problem with the above Design :**

The problem is now we have many subsystems like Validator, CustomerDataAccessLayer, and Email. And the Client needs to follow the appropriate sequence to create and consume the objects of the above subsystems. And here, there is a high chance that the client might not follow the proper sequence, or the client might forget to use one of the subsystems.

 

Implementing Facade Design Pattern:

```
namespace FacadeDesignPatternRealTimeExample
{
    public class CustomerRegistration
    {
        public bool RegisterCustomer(Customer customer)
        {
            //Step1: Validate the Customer
            Validator validator = new Validator();
            bool IsValid = validator.ValidateCustomer(customer);

            //Step1: Save the Customer Object into the database
            CustomerDataAccessLayer customerDataAccessLayer = new CustomerDataAccessLayer();
            bool IsSaved = customerDataAccessLayer.SaveCustomer(customer);

            //Step3: Send the Registration Email to the Customer
            Email email = new Email();
            email.SendRegistrationEmail(customer);

            return true;
        }
    }
}

 
using System;
namespace FacadeDesignPatternRealTimeExample
{
    class Program
    {
        static void Main(string[] args)
        {
            // Create an Instance of Customer Class
            Customer customer = new Customer()
            {
                Name = "Pranaya",
                Email = info@dotnettutorials.net,
                MobileNumber = "1234567890",
                Address = "BBSR, Odisha, India"
            };

            //Using Facade Class
            CustomerRegistration customerRegistration = new CustomerRegistration();
            customerRegistration.RegisterCustomer(customer);

            Console.ReadKey();
        }
    }
}

```